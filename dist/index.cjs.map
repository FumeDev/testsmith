{"version":3,"sources":["../src/index.ts","../src/ai/aiAdapter.ts","../src/auto/setup.ts","../src/utils/safeClick.ts","../src/utils/safeDoubleClick.ts","../src/actions/click.ts","../src/actions/hover.ts","../src/actions/drag.ts","../src/actions/scroll.ts","../src/actions/keypress.ts","../src/actions/cookie.ts","../src/actions/fill.ts","../src/actions/upload.ts","../src/actions/extract.ts","../src/actions/waitUntil.ts","../src/actions/navigation.ts"],"sourcesContent":["import { setupTestsmith } from './auto/setup';\nsetupTestsmith();\n\nexport type { Page, StagehandPage, Observation, ProgressTrackerLike } from './types/page';\n\nexport { clickAction, doubleClickAction } from './actions/click';\nexport { hoverAction } from './actions/hover';\nexport { dragAction } from './actions/drag';\nexport { scrollAction } from './actions/scroll';\nexport { keypressAction } from './actions/keypress';\nexport { cookieAction } from './actions/cookie';\nexport { fillAction } from './actions/fill';\nexport { uploadFileAction } from './actions/upload';\nexport { extractAction, assertAction } from './actions/extract';\nexport { waitUntil } from './actions/waitUntil';\nexport { navigateAction, refreshAction } from './actions/navigation';\n\nexport { aiAct, aiExtract, aiAssert, expectAiAssert, setStagehandInstance } from './ai/aiAdapter';\n\nexport { safeClick } from './utils/safeClick';\nexport { safeDoubleClick } from './utils/safeDoubleClick'; ","import type { Page } from '../types/page';\n\nlet stagehandInstance: any | null = null;\n\nexport function setStagehandInstance(instance: any) {\n  stagehandInstance = instance;\n}\n\nasync function getStagehandInstance(): Promise<any | null> {\n  // Prefer explicitly set instance, then global, else null\n  if (stagehandInstance) return stagehandInstance;\n  // @ts-ignore\n  if ((globalThis as any).stagehand) return (globalThis as any).stagehand;\n  return null;\n}\n\n// ------------------ aiAct ------------------\n\nexport async function aiAct(\n  page: Page,\n  description: string,\n  timeout: number = 30000\n): Promise<boolean> {\n  const testId = (page as any).progressTracker?.getTestId?.() || `act-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;\n\n  // Wait for page readiness (best-effort)\n  try {\n    await page.waitForLoadState('domcontentloaded', { timeout });\n  } catch {}\n\n  try {\n    const stagehand = await getStagehandInstance();\n    if (!stagehand) {\n      // Fallback: try using page.observe as a last resort signal the action could be performed\n      const observations = await page.observe(description);\n      (page as any).progressTracker?.addStep?.(`Action: ${description}`);\n      return observations.length > 0;\n    }\n\n    const progressString = (page as any).progressTracker?.getProgressString?.();\n    const agent = stagehand.agent({\n      provider: 'openai',\n      model: 'computer-use-preview',\n      instructions: `You are a persistent AI agent operating a web browser to perform a QA test step that Playwright failed to perform. Execute precisely the requested step and stop immediately after it is completed.\\n\\nPrevious steps:\\n${progressString || 'N/A'}`,\n    });\n\n    const result = await agent.execute(description);\n    const success = !!result?.success;\n\n    if (success) {\n      (page as any).progressTracker?.addStep?.(`Action: ${description}`);\n    }\n    return success;\n  } catch {\n    return false;\n  }\n}\n\n// ------------------ aiExtract ------------------\n\nexport interface AiUtilityConfig {\n  apiKey?: string;\n  endpoint?: string;\n  apiVersion?: string;\n  deploymentName?: string;\n  aiRequestTimeout?: number;\n  screenshotDir?: string;\n  skipAttachScreenshot?: boolean;\n}\n\nconst defaultExtractConfig: AiUtilityConfig = {\n  apiKey: process.env.AZURE_API_KEY,\n  endpoint: process.env.AZURE_API_BASE,\n  apiVersion: process.env.AZURE_API_VERSION || '2024-02-15-preview',\n  deploymentName: process.env.AZURE_OPENAI_DEPLOYMENT_NAME || 'gpt-4.1',\n  aiRequestTimeout: 180000,\n  screenshotDir: 'test-results',\n  skipAttachScreenshot: false,\n};\n\nasync function initAzureClient(config: AiUtilityConfig) {\n  // Dynamic import to avoid build-time dependency on openai types\n  const { AzureOpenAI } = await import('openai');\n  return new AzureOpenAI({\n    apiKey: config.apiKey,\n    endpoint: config.endpoint,\n    apiVersion: config.apiVersion,\n  } as any);\n}\n\nexport async function aiExtract(\n  page: Page,\n  variableName: string,\n  extractionGuide: string,\n  config: AiUtilityConfig = {},\n  pageLoadTimeout: number = 5000,\n  retryCount: number = 0\n): Promise<string> {\n  const { test } = await import('@playwright/test');\n  const fs = await import('fs');\n  const path = await import('path');\n\n  const mergedConfig = { ...defaultExtractConfig, ...config };\n  const testId = (page as any).progressTracker?.getTestId?.() || `aiExtract-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;\n\n  try { await page.waitForLoadState('domcontentloaded', { timeout: pageLoadTimeout }); } catch {}\n  try { await page.waitForLoadState('networkidle', { timeout: pageLoadTimeout }); } catch {}\n  await page.waitForTimeout(1000);\n\n  return await test.step(`AI Extract: ${variableName} - Guide: \"${extractionGuide.substring(0, 100)}...\"`, async () => {\n    const openai = await initAzureClient(mergedConfig);\n\n    const screenshotDir = mergedConfig.screenshotDir!;\n    if (!fs.existsSync(screenshotDir)) {\n      fs.mkdirSync(screenshotDir, { recursive: true });\n    }\n\n    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n    const screenshotPath = path.join(screenshotDir, `aiExtract-${variableName}-${timestamp}.png`);\n\n    await test.step(`Taking screenshot for ${variableName}`, async () => {\n      await page.screenshot({ path: screenshotPath });\n      if (!mergedConfig.skipAttachScreenshot) {\n        await test.info().attachments.push({\n          name: `Screenshot for extracting ${variableName}`,\n          contentType: 'image/png',\n          path: screenshotPath,\n        });\n      }\n    });\n\n    const imageData = fs.readFileSync(screenshotPath);\n    const base64Image = imageData.toString('base64');\n    const pageUrl = page.url();\n\n    let controller: AbortController | null = null;\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    try {\n      return await test.step(`Analyzing with ${mergedConfig.deploymentName} for ${variableName}`, async () => {\n        controller = new AbortController();\n        const timeoutPromise = new Promise((_, reject) => {\n          timeoutId = setTimeout(() => {\n            reject(new Error(`AI request for ${variableName} timed out after ${mergedConfig.aiRequestTimeout}ms`));\n            controller?.abort();\n          }, mergedConfig.aiRequestTimeout);\n        });\n\n        const progressString = (page as any).progressTracker?.getProgressString?.() || 'N/A';\n        const messages: any[] = [\n          {\n            role: 'system',\n            content: `You are a specialized AI assistant that extracts specific information from webpage screenshots.\\n\\nInstructions:\\n- Analyze the screenshot.\\n- Follow the extraction guide.\\n- Provide detailed reasoning within <reasoning>...</reasoning> and the value within <extracted_value>...</extracted_value>.\\n- If loading, return <wait/> instead.\\n\\nTest Case Progress:\\n${progressString}`,\n          },\n          {\n            role: 'user',\n            content: [\n              { type: 'text', text: `Variable to extract: \"${variableName}\"\\n\\nExtraction Guide:\\n${extractionGuide}\\n\\nCurrent page URL: ${pageUrl}` },\n              { type: 'image_url', image_url: { url: `data:image/png;base64,${base64Image}` } },\n            ],\n          },\n        ];\n\n        const openaiPromise = (openai as any).chat.completions.create(\n          {\n            model: mergedConfig.deploymentName!,\n            messages,\n            temperature: 0,\n          },\n          { signal: (controller as AbortController).signal }\n        );\n\n        const response: any = await Promise.race([openaiPromise, timeoutPromise]);\n        if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }\n\n        const aiResponseContent = response.choices[0]?.message?.content?.trim() || '';\n\n        const reasoningMatch = aiResponseContent.match(/<reasoning>([\\s\\S]*?)<\\/reasoning>/i);\n        const extractedValueMatch = aiResponseContent.match(/<extracted_value>([\\s\\S]*?)<\\/extracted_value>/i);\n        const waitTagMatch = aiResponseContent.match(/<wait\\/>/i);\n\n        if (waitTagMatch) {\n          if (retryCount >= 10) {\n            throw new Error(`AI detected loading state for ${variableName} after ${retryCount + 1} attempts.`);\n          }\n          await new Promise(resolve => setTimeout(resolve, 5000));\n          return await aiExtract(page, variableName, extractionGuide, config, pageLoadTimeout, retryCount + 1);\n        }\n\n        if (extractedValueMatch) {\n          const value = extractedValueMatch[1].trim();\n          (page as any).progressTracker?.addStep?.(`Extracted Variable '${variableName}' as '${value}'`);\n          return value;\n        }\n\n        // Fallback: attempt to parse raw content\n        const fallback = aiResponseContent.replace(/<[^>]+>/g, '').trim();\n        if (fallback) {\n          (page as any).progressTracker?.addStep?.(`Extracted Variable '${variableName}' as '${fallback}'`);\n          return fallback;\n        }\n\n        throw new Error(`AI response not in expected format for ${variableName}`);\n      });\n    } finally {\n      if (timeoutId) { clearTimeout(timeoutId); }\n    }\n  });\n}\n\n// ------------------ aiAssert ------------------\n\ninterface AiAssertConfig {\n  apiKey?: string;\n  endpoint?: string;\n  apiVersion?: string;\n  deploymentName?: string;\n  timeout?: number; // for page load wait in our wrapper; OpenAI timeout handled via AbortController in messages\n  screenshotDir?: string;\n  skipAttachScreenshot?: boolean;\n}\n\nconst defaultAssertConfig: AiAssertConfig = {\n  apiKey: process.env.AZURE_API_KEY,\n  endpoint: process.env.AZURE_API_BASE,\n  apiVersion: process.env.AZURE_API_VERSION || '2024-02-15-preview',\n  deploymentName: process.env.AZURE_OPENAI_DEPLOYMENT_NAME || 'gpt-4.1',\n  timeout: 45000,\n  screenshotDir: 'test-results',\n  skipAttachScreenshot: false,\n};\n\nexport async function aiAssert(\n  page: Page,\n  prompt: string,\n  config: AiAssertConfig = {},\n  timeout: number = 1000,\n  retryCount: number = 0,\n  timeoutRetryCount: number = 0\n): Promise<boolean> {\n  const { test } = await import('@playwright/test');\n  const fs = await import('fs');\n  const path = await import('path');\n\n  const mergedConfig = { ...defaultAssertConfig, ...config };\n  const testId = (page as any).progressTracker?.getTestId?.() || `test-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;\n\n  try { await page.waitForLoadState('domcontentloaded', { timeout }); } catch {}\n  await page.waitForTimeout(1000);\n\n  return await test.step(`AI Vision Assert: ${prompt}`, async () => {\n    const openai = await initAzureClient(mergedConfig);\n\n    const screenshotDir = mergedConfig.screenshotDir!;\n    if (!fs.existsSync(screenshotDir)) {\n      fs.mkdirSync(screenshotDir, { recursive: true });\n    }\n\n    let base64Image = '';\n    let screenshotPath = '';\n\n    await test.step(`Taking screenshot`, async () => {\n      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');\n      screenshotPath = path.join(screenshotDir, `aiAssert-${timestamp}.png`);\n      await page.screenshot({ path: screenshotPath });\n    });\n\n    const imageData = fs.readFileSync(screenshotPath);\n    base64Image = imageData.toString('base64');\n    const pageUrl = page.url();\n\n    let controller: AbortController | null = null;\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    try {\n      return await test.step(`Analyzing with ${mergedConfig.deploymentName}`, async () => {\n        controller = new AbortController();\n        const timeoutPromise = new Promise((_, reject) => {\n          timeoutId = setTimeout(() => {\n            reject(new Error(`AI request timed out after ${mergedConfig.timeout}ms`));\n            controller?.abort();\n          }, mergedConfig.timeout);\n        });\n\n        const progressString = (page as any).progressTracker?.getProgressString?.();\n        const messages: any[] = [\n          {\n            role: 'system',\n            content: `You are a specialized testing assistant that analyzes webpage screenshots. Provide <reasoning>...</reasoning> and final decision in <decision>pass|major-fail|minor-fail|partial-fail|wait</decision>.\\n\\nPrevious steps:\\n${progressString || 'N/A'}`,\n          },\n          {\n            role: 'user',\n            content: [\n              { type: 'text', text: `Condition: ${prompt}\\n\\nCurrent page URL: ${pageUrl}` },\n              { type: 'image_url', image_url: { url: `data:image/png;base64,${base64Image}` } },\n            ],\n          },\n        ];\n\n        const openaiPromise = (openai as any).chat.completions.create(\n          {\n            model: mergedConfig.deploymentName!,\n            messages,\n          },\n          { signal: (controller as AbortController).signal }\n        );\n\n        let response: any;\n        try {\n          response = await Promise.race([openaiPromise, timeoutPromise]);\n          if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }\n        } catch (error: any) {\n          if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; }\n          // Retry on timeout a couple of times\n          if (error?.message?.includes('timed out') && timeoutRetryCount < 2) {\n            try { fs.unlinkSync(screenshotPath); } catch {}\n            await new Promise((r) => setTimeout(r, 5000));\n            return await aiAssert(page, prompt, config, timeout, retryCount, timeoutRetryCount + 1);\n          }\n          throw error;\n        }\n\n        const aiResponse = response.choices[0]?.message?.content?.trim() || '';\n        const decisionMatch = aiResponse.match(/<decision>(pass|major-fail|minor-fail|partial-fail|wait)<\\/decision>/i);\n\n        let decision: boolean | null = null;\n        if (!decisionMatch) {\n          const normalized = aiResponse.toLowerCase().trim();\n          if (normalized === 'pass') decision = true;\n          else if (normalized === 'major-fail') decision = false;\n          else if (normalized === 'minor-fail' || normalized === 'partial-fail') decision = true;\n          else decision = null;\n        }\n\n        if (decision === null && decisionMatch) {\n          const value = decisionMatch[1].toLowerCase();\n          if (value === 'wait' || value === 'major-fail') {\n            if (value === 'major-fail' && retryCount >= 3) {\n              return false;\n            } else if (value === 'wait' && retryCount >= 10) {\n              return false;\n            }\n            try { fs.unlinkSync(screenshotPath); } catch {}\n            await new Promise((r) => setTimeout(r, 10000));\n            return await aiAssert(page, prompt, config, timeout, retryCount + 1, timeoutRetryCount);\n          } else if (value === 'minor-fail' || value === 'partial-fail') {\n            decision = true;\n          } else {\n            decision = value === 'pass';\n          }\n        }\n\n        const finalDecision = !!decision;\n        // Persist assertion record if supported by the tracker\n        (page as any).progressTracker?.addAiAssertion?.(prompt, base64Image, finalDecision);\n\n        if (!mergedConfig.skipAttachScreenshot) {\n          await (await import('@playwright/test')).test.info().attachments.push({\n            name: `Screenshot for: ${prompt}`,\n            contentType: 'image/png',\n            path: screenshotPath,\n          });\n        }\n\n        return finalDecision;\n      });\n    } finally {\n      if (timeoutId) { clearTimeout(timeoutId); }\n    }\n  });\n}\n\nexport async function expectAiAssert(\n  page: Page,\n  prompt: string,\n  config: AiAssertConfig = {}\n): Promise<void> {\n  const { expect, test } = await import('@playwright/test');\n  await test.step(`Assertion: ${prompt}`, async () => {\n    const result = await aiAssert(page, prompt, config);\n    await test.step(result ? `✅ PASSED: ${prompt}` : `❌ FAILED: ${prompt}`, async () => {});\n    expect(result, `AI assertion failed for: ${prompt}`).toBe(true);\n  });\n} ","import { setStagehandInstance } from '../ai/aiAdapter';\n\nlet initialized = false;\n\nexport function setupTestsmith(): void {\n  if (initialized) return;\n  initialized = true;\n\n  // Try to set stagehand instance from a local import if present\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const maybeStagehand = require('stagehand');\n    if (maybeStagehand) {\n      setStagehandInstance(maybeStagehand);\n    }\n  } catch {\n    // ignore if stagehand is not installed\n  }\n\n  // Also check globalThis.stagehand if provided by the test runtime\n  // @ts-ignore\n  if ((globalThis as any).stagehand) {\n    // @ts-ignore\n    setStagehandInstance((globalThis as any).stagehand);\n  }\n} ","import type { Page } from '../types/page';\n\nexport async function safeClick(page: Page, selector: string): Promise<{ success: boolean }> {\n  try {\n    const locator = page.locator(selector);\n    await locator.waitFor({ state: 'visible', timeout: 10000 });\n    await locator.click();\n    return { success: true };\n  } catch (error) {\n    return { success: false };\n  }\n} ","import type { Page } from '../types/page';\n\nexport async function safeDoubleClick(page: Page, selector: string): Promise<{ success: boolean }> {\n  try {\n    const locator = page.locator(selector);\n    await locator.waitFor({ state: 'visible', timeout: 10000 });\n    await locator.dblclick();\n    return { success: true };\n  } catch (error) {\n    return { success: false };\n  }\n} ","import type { Page } from '../types/page';\nimport { aiAct } from '../ai/aiAdapter';\nimport { safeClick } from '../utils/safeClick';\nimport { safeDoubleClick } from '../utils/safeDoubleClick';\n\nexport async function clickAction(\n  page: Page,\n  description: string,\n  selector?: string,\n  options?: { variable?: string; defaultValue?: string }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  if (selector) {\n    if (options?.variable && options?.defaultValue) {\n      if (options.variable === options.defaultValue) {\n        const clickResult = await safeClick(page, selector);\n        actionSuccess = clickResult.success;\n      }\n    } else {\n      const clickResult = await safeClick(page, selector);\n      actionSuccess = clickResult.success;\n    }\n  }\n\n  if (!actionSuccess) {\n    actionSuccess = await aiAct(page, description);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n}\n\nexport async function doubleClickAction(\n  page: Page,\n  description: string,\n  selector?: string,\n  options?: { variable?: string; defaultValue?: string }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  if (selector) {\n    if (options?.variable && options?.defaultValue) {\n      if (options.variable === options.defaultValue) {\n        const clickResult = await safeDoubleClick(page, selector);\n        actionSuccess = clickResult.success;\n      }\n    } else {\n      const clickResult = await safeDoubleClick(page, selector);\n      actionSuccess = clickResult.success;\n    }\n  }\n\n  if (!actionSuccess) {\n    actionSuccess = await aiAct(page, description);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\nimport { aiAct } from '../ai/aiAdapter';\n\nexport async function hoverAction(\n  page: Page,\n  description: string,\n  selector?: string,\n  options?: { variable?: string; defaultValue?: string }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  if (selector) {\n    if (options?.variable && options?.defaultValue) {\n      if (options.variable === options.defaultValue) {\n        try {\n          const locator = page.locator(selector);\n          await locator.waitFor({ state: 'visible', timeout: 10000 });\n          await locator.hover();\n          actionSuccess = true;\n        } catch {\n          actionSuccess = false;\n        }\n      }\n    } else {\n      try {\n        const locator = page.locator(selector);\n        await locator.waitFor({ state: 'visible', timeout: 10000 });\n        await locator.hover();\n        actionSuccess = true;\n      } catch {\n        actionSuccess = false;\n      }\n    }\n  }\n\n  if (!actionSuccess) {\n    actionSuccess = await aiAct(page, description);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\nimport { aiAct } from '../ai/aiAdapter';\n\nexport async function dragAction(\n  page: Page,\n  description: string,\n  sourceSelector?: string,\n  dragOptions?: {\n    targetSelector?: string;\n    offset?: { x: number; y: number };\n    variable?: string;\n    defaultValue?: string;\n  }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  if (sourceSelector) {\n    const shouldUseDrag = !dragOptions?.variable || !dragOptions?.defaultValue ||\n      (dragOptions.variable === dragOptions.defaultValue);\n\n    if (shouldUseDrag) {\n      try {\n        const sourceLocator = page.locator(sourceSelector);\n        await sourceLocator.waitFor({ state: 'visible', timeout: 10000 });\n\n        if (dragOptions?.targetSelector) {\n          const targetLocator = page.locator(dragOptions.targetSelector);\n          await targetLocator.waitFor({ state: 'visible', timeout: 10000 });\n          await sourceLocator.dragTo(targetLocator);\n          actionSuccess = true;\n        } else if (dragOptions?.offset) {\n          const sourceBox = await sourceLocator.boundingBox();\n          if (sourceBox) {\n            await page.mouse.move(sourceBox.x + sourceBox.width / 2, sourceBox.y + sourceBox.height / 2);\n            await page.mouse.down();\n            await page.mouse.move(\n              sourceBox.x + sourceBox.width / 2 + dragOptions.offset.x,\n              sourceBox.y + sourceBox.height / 2 + dragOptions.offset.y\n            );\n            await page.mouse.up();\n            actionSuccess = true;\n          }\n        } else {\n          const sourceBox = await sourceLocator.boundingBox();\n          if (sourceBox) {\n            await page.mouse.move(sourceBox.x + sourceBox.width / 2, sourceBox.y + sourceBox.height / 2);\n            await page.mouse.down();\n            await page.mouse.move(sourceBox.x + sourceBox.width / 2 + 10, sourceBox.y + sourceBox.height / 2 + 10);\n            await page.mouse.up();\n            actionSuccess = true;\n          }\n        }\n      } catch {\n        actionSuccess = false;\n      }\n    }\n  }\n\n  if (!actionSuccess) {\n    actionSuccess = await aiAct(page, description);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\nimport { aiAct } from '../ai/aiAdapter';\n\nexport async function scrollAction(\n  page: Page,\n  description: string,\n  selector?: string,\n  scrollOptions?: {\n    deltaX?: number;\n    deltaY?: number;\n    direction?: 'up' | 'down' | 'left' | 'right';\n    amount?: 'small' | 'medium' | 'large' | number;\n    scrollToSelector?: string;\n    variable?: string;\n    defaultValue?: string;\n  }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  let deltaX = scrollOptions?.deltaX ?? 0;\n  let deltaY = scrollOptions?.deltaY ?? 0;\n\n  if (scrollOptions?.direction) {\n    const scrollAmount = typeof scrollOptions.amount === 'number'\n      ? scrollOptions.amount\n      : scrollOptions?.amount === 'small' ? 100\n      : scrollOptions?.amount === 'large' ? 500\n      : 300;\n\n    switch (scrollOptions.direction) {\n      case 'up': deltaY = -scrollAmount; break;\n      case 'down': deltaY = scrollAmount; break;\n      case 'left': deltaX = -scrollAmount; break;\n      case 'right': deltaX = scrollAmount; break;\n    }\n  }\n\n  if (deltaX === 0 && deltaY === 0 && !scrollOptions?.scrollToSelector) {\n    deltaY = 300;\n  }\n\n  if (selector || scrollOptions?.scrollToSelector) {\n    const shouldUseScroll = !scrollOptions?.variable || !scrollOptions?.defaultValue ||\n      (scrollOptions.variable === scrollOptions.defaultValue);\n\n    if (shouldUseScroll) {\n      try {\n        if (scrollOptions?.scrollToSelector) {\n          const targetLocator = page.locator(scrollOptions.scrollToSelector);\n          await targetLocator.waitFor({ state: 'visible', timeout: 10000 });\n          await targetLocator.scrollIntoViewIfNeeded();\n          actionSuccess = true;\n        } else if (selector) {\n          const locator = page.locator(selector);\n          await locator.waitFor({ state: 'visible', timeout: 10000 });\n          await locator.hover();\n          await page.mouse.wheel(deltaX, deltaY);\n          actionSuccess = true;\n        }\n      } catch {\n        actionSuccess = false;\n      }\n    }\n  } else {\n    try {\n      await page.mouse.wheel(deltaX, deltaY);\n      actionSuccess = true;\n    } catch {\n      actionSuccess = false;\n    }\n  }\n\n  if (!actionSuccess) {\n    actionSuccess = await aiAct(page, description);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\nimport { aiAct } from '../ai/aiAdapter';\nimport { safeClick } from '../utils/safeClick';\n\nexport async function keypressAction(\n  page: Page,\n  description: string,\n  keys: string | string[],\n  selector?: string,\n  options?: {\n    variable?: string;\n    defaultValue?: string;\n    focusFirst?: boolean;\n  }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  const keyString = Array.isArray(keys) ? keys.join('+') : keys;\n\n  const normalizeKey = (key: string): string => {\n    const keyMap: { [key: string]: string } = {\n      'CTRL': 'Control',\n      'ALT': 'Alt',\n      'SHIFT': 'Shift',\n      'ENTER': 'Enter',\n      'ESC': 'Escape',\n      'SPACE': ' ',\n      'TAB': 'Tab',\n      'DELETE': 'Delete',\n      'BACKSPACE': 'Backspace',\n      'ARROW_UP': 'ArrowUp',\n      'ARROW_DOWN': 'ArrowDown',\n      'ARROW_LEFT': 'ArrowLeft',\n      'ARROW_RIGHT': 'ArrowRight',\n      'HOME': 'Home',\n      'END': 'End',\n      'PAGE_UP': 'PageUp',\n      'PAGE_DOWN': 'PageDown'\n    };\n\n    return keyMap[key.toUpperCase()] || key;\n  };\n\n  const normalizedKeys = Array.isArray(keys)\n    ? keys.map(normalizeKey).join('+')\n    : normalizeKey(keyString);\n\n  if (selector) {\n    const shouldUseKeypress = !options?.variable || !options?.defaultValue ||\n      (options.variable === options.defaultValue);\n\n    if (shouldUseKeypress) {\n      try {\n        const locator = page.locator(selector);\n        await locator.waitFor({ state: 'visible', timeout: 10000 });\n\n        if (options?.focusFirst !== false) {\n          const clickResult = await safeClick(page, selector);\n          if (!clickResult.success) {\n            await locator.focus();\n          }\n        }\n\n        await page.keyboard.press(normalizedKeys);\n        actionSuccess = true;\n      } catch {\n        actionSuccess = false;\n      }\n    }\n  } else {\n    try {\n      await page.keyboard.press(normalizedKeys);\n      actionSuccess = true;\n    } catch {\n      actionSuccess = false;\n    }\n  }\n\n  if (!actionSuccess) {\n    actionSuccess = await aiAct(page, description);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\n\ninterface CookieData {\n  name: string;\n  value: string;\n  domain: string;\n  path?: string;\n  expires?: number;\n  httpOnly?: boolean;\n  secure?: boolean;\n  sameSite?: 'Strict' | 'Lax' | 'None';\n}\n\nexport async function cookieAction(\n  page: Page,\n  cookieData: CookieData | CookieData[],\n  description?: string,\n  options?: { variable?: string; defaultValue?: string }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  const cookies = Array.isArray(cookieData) ? cookieData : [cookieData];\n\n  let actionDescription = description;\n  if (!actionDescription) {\n    if (cookies.length === 1) {\n      actionDescription = `Injected cookie ${cookies[0].name}`;\n    } else {\n      const cookieNames = cookies.map(c => c.name).join(', ');\n      actionDescription = `Injected cookies: ${cookieNames}`;\n    }\n  }\n\n  const escapeCookieValue = (value: string): string => {\n    return value.replace(/[\";,\\s]/g, (match) => {\n      switch (match) {\n        case '\"': return '\\\\\"';\n        case ';': return '\\\\;';\n        case ',': return '\\\\,';\n        case ' ': return '%20';\n        default: return match;\n      }\n    });\n  };\n\n  const processedCookies = cookies.map(cookie => ({\n    name: cookie.name,\n    value: escapeCookieValue(cookie.value),\n    domain: cookie.domain,\n    path: cookie.path || '/',\n    expires: cookie.expires,\n    httpOnly: cookie.httpOnly,\n    secure: cookie.secure,\n    sameSite: cookie.sameSite\n  }));\n\n  const shouldInjectCookies = !options?.variable || !options?.defaultValue ||\n    (options.variable === options.defaultValue);\n\n  if (shouldInjectCookies) {\n    try {\n      await page.context().addCookies(processedCookies);\n      actionSuccess = true;\n    } catch (e) {\n      actionSuccess = false;\n    }\n  } else {\n    actionSuccess = true;\n  }\n\n  page.progressTracker.addStep(actionDescription, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\nimport { aiAct } from '../ai/aiAdapter';\n\nexport async function fillAction(\n  page: Page,\n  description: string,\n  value: string,\n  selector?: string,\n  options?: { variable?: string; defaultValue?: string }\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  if (selector) {\n    if (options?.variable && options?.defaultValue) {\n      if (options.variable === options.defaultValue) {\n        try {\n          const locator = page.locator(selector);\n          await locator.waitFor({ state: 'visible', timeout: 10000 });\n          await locator.fill(value);\n          actionSuccess = true;\n        } catch {\n          actionSuccess = false;\n        }\n      }\n    } else {\n      try {\n        const locator = page.locator(selector);\n        await locator.waitFor({ state: 'visible', timeout: 10000 });\n        await locator.fill(value);\n        actionSuccess = true;\n      } catch {\n        actionSuccess = false;\n      }\n    }\n  }\n\n  if (!actionSuccess) {\n    const aiDescription = `${description}. Fill the field with the value: ${value}`;\n    actionSuccess = await aiAct(page, aiDescription);\n  }\n\n  page.progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page as PlaywrightPage } from '@playwright/test';\nimport type { Page } from '../types/page';\n\nexport async function uploadFileAction(\n  page: PlaywrightPage,\n  description: string,\n  filePaths: string | string[],\n  selector?: string\n): Promise<boolean> {\n  let actionSuccess = false;\n\n  const filesArray = Array.isArray(filePaths) ? filePaths : [filePaths];\n\n  if (selector) {\n    try {\n      const locator = page.locator(selector);\n      await locator.waitFor({ state: 'attached', timeout: 10000 });\n      await locator.setInputFiles(filesArray);\n      actionSuccess = true;\n    } catch {\n      actionSuccess = false;\n    }\n  }\n\n  if (!actionSuccess) {\n    try {\n      const observations = await (page as unknown as Page).observe(description);\n      if (observations.length > 0) {\n        const fileInputObservations = observations.filter(obs =>\n          obs.selector && (\n            (obs.selector as string).includes('input[type=\"file\"]') ||\n            (obs.selector as string).includes('input[type=file]') ||\n            obs.description.toLowerCase().includes('file input') ||\n            obs.description.toLowerCase().includes('input file')\n          )\n        );\n\n        let bestCandidate = fileInputObservations[0] ?? observations[0];\n\n        if (bestCandidate?.selector) {\n          const locator = page.locator(bestCandidate.selector as string);\n          try {\n            await locator.waitFor({ state: 'attached', timeout: 10000 });\n            await locator.setInputFiles(filesArray);\n            actionSuccess = true;\n          } catch {\n            if (!(bestCandidate.selector as string).includes('input[type=\"file\"]')) {\n              try {\n                await locator.click();\n                await page.waitForTimeout(1000);\n                const fileInput = page.locator('input[type=\"file\"]').first();\n                await fileInput.waitFor({ state: 'attached', timeout: 5000 });\n                await fileInput.setInputFiles(filesArray);\n                actionSuccess = true;\n              } catch {\n                actionSuccess = false;\n              }\n            }\n          }\n        }\n      }\n    } catch {\n      actionSuccess = false;\n    }\n  }\n\n  (page as unknown as Page).progressTracker.addStep(description, actionSuccess);\n  return actionSuccess;\n} ","import type { Page } from '../types/page';\nimport { aiExtract, expectAiAssert } from '../ai/aiAdapter';\n\nexport async function extractAction(\n  page: Page,\n  variableName: string,\n  description: string\n): Promise<string> {\n  const extractedValue = await aiExtract(page, variableName, description);\n  page.progressTracker.addStep(`Extracted Variable '${variableName}' as '${extractedValue}'`);\n  return extractedValue;\n}\n\nexport async function assertAction(\n  page: Page,\n  description: string\n): Promise<void> {\n  await expectAiAssert(page, description);\n  page.progressTracker.addStep(description);\n} ","import type { Page } from '../types/page';\nimport { aiAssert } from '../ai/aiAdapter';\n\nconst WAIT_UNTIL_INTERVAL_MS = 10000;\nconst WAIT_UNTIL_TIMEOUT_MS = 300000;\n\nexport async function waitUntil(page: Page, condition: string): Promise<boolean> {\n  const startTime = Date.now();\n  let conditionMet = false;\n\n  while (Date.now() - startTime < WAIT_UNTIL_TIMEOUT_MS) {\n    try {\n      conditionMet = await aiAssert(page, condition, { timeout: WAIT_UNTIL_TIMEOUT_MS });\n    } catch {\n      conditionMet = false;\n    }\n\n    if (conditionMet) {\n      break;\n    }\n\n    await page.waitForTimeout(WAIT_UNTIL_INTERVAL_MS);\n  }\n\n  const description = `Wait until condition met: ${condition}`;\n  page.progressTracker.addStep(description, conditionMet);\n  return conditionMet;\n} ","import type { Page } from '../types/page';\n\nexport async function navigateAction(\n  page: Page,\n  url: string,\n  description?: string\n): Promise<void> {\n  const actionDescription = description || `Navigated to ${url}`;\n\n  await page.waitForTimeout(1000);\n  await page.goto(url).catch(() => {});\n\n  try {\n    await page.waitForLoadState('domcontentloaded', { timeout: 10000 });\n  } catch {\n    // ignore\n  }\n\n  try {\n    await page.waitForLoadState('networkidle', { timeout: 10000 });\n  } catch {\n    // ignore\n  }\n\n  page.progressTracker.addStep(actionDescription);\n}\n\nexport async function refreshAction(\n  page: Page,\n  description?: string\n): Promise<void> {\n  const actionDescription = description || 'Refreshed the page';\n  await page.reload();\n  page.progressTracker.addStep(actionDescription);\n} "],"mappings":"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","names":[]}